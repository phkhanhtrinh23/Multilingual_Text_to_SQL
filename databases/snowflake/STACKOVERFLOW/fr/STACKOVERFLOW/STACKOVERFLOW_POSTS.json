{
  "table_name": "STACKOVERFLOW_POSTS",
  "table_fullname": "STACKOVERFLOW.STACKOVERFLOW.STACKOVERFLOW_POSTS",
  "column_names": [
    "étiquettes",
    "score",
    "nom_d_affichage_du_dernier_éditeur",
    "compte_de_commentaires",
    "date_de_dernière_édition",
    "id_parent",
    "compte_de_favoris",
    "date_de_création",
    "compte_de_réponses",
    "nom_d_affichage_du_propriétaire",
    "corps",
    "titre",
    "date_de_propriété_communautaire",
    "id",
    "date_de_dernière_activité",
    "id_utilisateur_du_dernier_éditeur",
    "id_utilisateur_du_propriétaire",
    "id_de_type_de_poste",
    "compte_de_vues",
    "id_de_réponse_acceptée"
  ],
  "column_types": [
    "TEXT",
    "NUMBER",
    "TEXT",
    "NUMBER",
    "NUMBER",
    "NUMBER",
    "NUMBER",
    "NUMBER",
    "NUMBER",
    "TEXT",
    "TEXT",
    "TEXT",
    "NUMBER",
    "NUMBER",
    "NUMBER",
    "NUMBER",
    "NUMBER",
    "NUMBER",
    "NUMBER",
    "NUMBER"
  ],
  "description": [
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "sample_rows": [
    {
      "id": 12043418,
      "titre": null,
      "corps": "<pre><code>lis = ['fi' 'do' 'ca'] for item in lis: for name in glob.glob('*.html'): if item in name: with open(name) as k: </code></pre> <p>or create a list of all files first and then filter that list with every iteration of <code>list</code>:</p> <pre><code>&gt;&gt;&gt; names=glob.glob('*.html') &gt;&gt;&gt; lis=['fi''do''ca'] &gt;&gt;&gt; for item in lis: ... for name in filter(lambda x:item in xnames): ... with open('name') as k: </code></pre>",
      "id_de_réponse_acceptée": null,
      "compte_de_réponses": null,
      "compte_de_commentaires": 6,
      "date_de_propriété_communautaire": null,
      "date_de_création": 1345488922380000,
      "compte_de_favoris": null,
      "date_de_dernière_activité": 1345489443110000,
      "date_de_dernière_édition": 1345489443110000.0,
      "nom_d_affichage_du_dernier_éditeur": null,
      "id_utilisateur_du_dernier_éditeur": 846892.0,
      "nom_d_affichage_du_propriétaire": null,
      "id_utilisateur_du_propriétaire": 846892,
      "id_parent": 12043365,
      "id_de_type_de_poste": 2,
      "score": 3,
      "étiquettes": "",
      "compte_de_vues": null
    },
    {
      "id": 19888120,
      "titre": null,
      "corps": "<p>it's possible using Django ORM:</p> <p>here's what you should do:</p> <pre><code>from django.db.models import Sum total = ( Task.objects .filter(your-filter-here) .aggregate( total=Sum('progress' field= progress*estimated_days ) )['total'] ) </code></pre> <p>Note: if the two fields are of different types say <code>integer</code> &amp; <code>float</code> the type you want to return should be passed as the first parameter of <code>Sum</code></p> <p>It's a late answer but I guess it'll help someone looking for the same.</p>",
      "id_de_réponse_acceptée": null,
      "compte_de_réponses": null,
      "compte_de_commentaires": 6,
      "date_de_propriété_communautaire": null,
      "date_de_création": 1384075370847000,
      "compte_de_favoris": null,
      "date_de_dernière_activité": 1458102533000000,
      "date_de_dernière_édition": 1458102533000000.0,
      "nom_d_affichage_du_dernier_éditeur": null,
      "id_utilisateur_du_dernier_éditeur": 1673391.0,
      "nom_d_affichage_du_propriétaire": null,
      "id_utilisateur_du_propriétaire": 1232826,
      "id_parent": 12165636,
      "id_de_type_de_poste": 2,
      "score": 39,
      "étiquettes": "",
      "compte_de_vues": null
    },
    {
      "id": 11656918,
      "titre": null,
      "corps": "<p>Your code as-is works: <a href= http://jsfiddle.net/vWRAw/ rel= nofollow >http://jsfiddle.net/vWRAw/</a></p> <p>The json being returned from your temp-webserver however is JSON and not JSONP. If you want to request it as JSON remove the <code>?callback=?</code> however that would mean your temp webserver would need to be on the same domain as the page making the request.</p>",
      "id_de_réponse_acceptée": null,
      "compte_de_réponses": null,
      "compte_de_commentaires": 6,
      "date_de_propriété_communautaire": null,
      "date_de_création": 1343243633750000,
      "compte_de_favoris": null,
      "date_de_dernière_activité": 1343243633750000,
      "date_de_dernière_édition": null,
      "nom_d_affichage_du_dernier_éditeur": null,
      "id_utilisateur_du_dernier_éditeur": null,
      "nom_d_affichage_du_propriétaire": null,
      "id_utilisateur_du_propriétaire": 400654,
      "id_parent": 11656868,
      "id_de_type_de_poste": 2,
      "score": 1,
      "étiquettes": "",
      "compte_de_vues": null
    },
    {
      "id": 3112592,
      "titre": null,
      "corps": "<p>Reference arguments were originally invented AFAIK for one thing: <strong>operator overloading semantics</strong>. For example operator[] just must return a reference.</p> <p>It was then a subject of great debate whether the 'concealed pointer' should be used for anything else ever. </p> <p>Many development convention documents of many firms said never use references. If you need a pointer say so .</p> <p>However it was then discovered that references have one major advantage (no not the syntax sugar). It is this: a reference is guaranteed to be valid unless you work really hard to break it.</p> <p>Personally I still don't understand why I cannot do this in C++:</p> <pre><code>int a1 a2; int &amp;b = a1; &amp;b = a2; // Error. address of referenced is not an lvalue. Why?! </code></pre>",
      "id_de_réponse_acceptée": null,
      "compte_de_réponses": null,
      "compte_de_commentaires": 6,
      "date_de_propriété_communautaire": null,
      "date_de_création": 1277402054163000,
      "compte_de_favoris": null,
      "date_de_dernière_activité": 1436303301943000,
      "date_de_dernière_édition": 1436303301943000.0,
      "nom_d_affichage_du_dernier_éditeur": null,
      "id_utilisateur_du_dernier_éditeur": 63550.0,
      "nom_d_affichage_du_propriétaire": null,
      "id_utilisateur_du_propriétaire": 73656,
      "id_parent": 3112550,
      "id_de_type_de_poste": 2,
      "score": 5,
      "étiquettes": "",
      "compte_de_vues": null
    },
    {
      "id": 11273340,
      "titre": null,
      "corps": "<p><code>Ishoppingcart::addToCart()</code> states that the method does not take any parameter while the implementation <code>Shoppingcart::addToCart(Product $product)</code> requires that a parameter of type <code>Product</code> must be passed into the method. This means that both declarations are incompatible and while the implemented interface must be satisfied PHP throws the shown error.</p> <p>Solution would be to either change <code>Ishoppingcart::addToCart()</code> to <code>Ishoppingcart::addToCart(Product $product)</code> so that it requires a parameter of type <code>Product</code> or to change <code>Shoppingcart::addToCart(Product $product)</code> to allow no parameter to passed into the method: <code>Shoppingcart::addToCart(Product $product = null)</code>;</p> <p>The correct way depends on your application requirements.</p>",
      "id_de_réponse_acceptée": null,
      "compte_de_réponses": null,
      "compte_de_commentaires": 6,
      "date_de_propriété_communautaire": null,
      "date_de_création": 1341051808937000,
      "compte_de_favoris": null,
      "date_de_dernière_activité": 1341051808937000,
      "date_de_dernière_édition": null,
      "nom_d_affichage_du_dernier_éditeur": null,
      "id_utilisateur_du_dernier_éditeur": null,
      "nom_d_affichage_du_propriétaire": null,
      "id_utilisateur_du_propriétaire": 11354,
      "id_parent": 11273313,
      "id_de_type_de_poste": 2,
      "score": 14,
      "étiquettes": "",
      "compte_de_vues": null
    }
  ]
}
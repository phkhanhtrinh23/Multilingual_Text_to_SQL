{
  "table_name": "STACKOVERFLOW_POSTS",
  "table_fullname": "STACKOVERFLOW.STACKOVERFLOW.STACKOVERFLOW_POSTS",
  "column_names": [
    "Schlagwörter",
    "Punktzahl",
    "Anzeigename_des_letzten_Bearbeiters",
    "Kommentaranzahl",
    "Letztes_Bearbeitungsdatum",
    "Eltern_ID",
    "Favoritenanzahl",
    "Erstellungsdatum",
    "Antwortanzahl",
    "Anzeigename_des_Besitzers",
    "Text",
    "Titel",
    "Gemeineigentumsdatum",
    "ID",
    "Letztes_Aktivitätsdatum",
    "Benutzer_ID_des_letzten_Bearbeiters",
    "Benutzer_ID_des_Besitzers",
    "Posttyp_ID",
    "Aufrufanzahl",
    "ID_der_akzeptierten_Antwort"
  ],
  "column_types": [
    "TEXT",
    "NUMBER",
    "TEXT",
    "NUMBER",
    "NUMBER",
    "NUMBER",
    "NUMBER",
    "NUMBER",
    "NUMBER",
    "TEXT",
    "TEXT",
    "TEXT",
    "NUMBER",
    "NUMBER",
    "NUMBER",
    "NUMBER",
    "NUMBER",
    "NUMBER",
    "NUMBER",
    "NUMBER"
  ],
  "description": [
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null
  ],
  "sample_rows": [
    {
      "ID": 12043418,
      "Titel": null,
      "Text": "<pre><code>lis = ['fi' 'do' 'ca'] for item in lis: for name in glob.glob('*.html'): if item in name: with open(name) as k: </code></pre> <p>or create a list of all files first and then filter that list with every iteration of <code>list</code>:</p> <pre><code>&gt;&gt;&gt; names=glob.glob('*.html') &gt;&gt;&gt; lis=['fi''do''ca'] &gt;&gt;&gt; for item in lis: ... for name in filter(lambda x:item in xnames): ... with open('name') as k: </code></pre>",
      "ID_der_akzeptierten_Antwort": null,
      "Antwortanzahl": null,
      "Kommentaranzahl": 6,
      "Gemeineigentumsdatum": null,
      "Erstellungsdatum": 1345488922380000,
      "Favoritenanzahl": null,
      "Letztes_Aktivitätsdatum": 1345489443110000,
      "Letztes_Bearbeitungsdatum": 1345489443110000.0,
      "Anzeigename_des_letzten_Bearbeiters": null,
      "Benutzer_ID_des_letzten_Bearbeiters": 846892.0,
      "Anzeigename_des_Besitzers": null,
      "Benutzer_ID_des_Besitzers": 846892,
      "Eltern_ID": 12043365,
      "Posttyp_ID": 2,
      "Punktzahl": 3,
      "Schlagwörter": "",
      "Aufrufanzahl": null
    },
    {
      "ID": 19888120,
      "Titel": null,
      "Text": "<p>it's possible using Django ORM:</p> <p>here's what you should do:</p> <pre><code>from django.db.models import Sum total = ( Task.objects .filter(your-filter-here) .aggregate( total=Sum('progress' field= progress*estimated_days ) )['total'] ) </code></pre> <p>Note: if the two fields are of different types say <code>integer</code> &amp; <code>float</code> the type you want to return should be passed as the first parameter of <code>Sum</code></p> <p>It's a late answer but I guess it'll help someone looking for the same.</p>",
      "ID_der_akzeptierten_Antwort": null,
      "Antwortanzahl": null,
      "Kommentaranzahl": 6,
      "Gemeineigentumsdatum": null,
      "Erstellungsdatum": 1384075370847000,
      "Favoritenanzahl": null,
      "Letztes_Aktivitätsdatum": 1458102533000000,
      "Letztes_Bearbeitungsdatum": 1458102533000000.0,
      "Anzeigename_des_letzten_Bearbeiters": null,
      "Benutzer_ID_des_letzten_Bearbeiters": 1673391.0,
      "Anzeigename_des_Besitzers": null,
      "Benutzer_ID_des_Besitzers": 1232826,
      "Eltern_ID": 12165636,
      "Posttyp_ID": 2,
      "Punktzahl": 39,
      "Schlagwörter": "",
      "Aufrufanzahl": null
    },
    {
      "ID": 11656918,
      "Titel": null,
      "Text": "<p>Your code as-is works: <a href= http://jsfiddle.net/vWRAw/ rel= nofollow >http://jsfiddle.net/vWRAw/</a></p> <p>The json being returned from your temp-webserver however is JSON and not JSONP. If you want to request it as JSON remove the <code>?callback=?</code> however that would mean your temp webserver would need to be on the same domain as the page making the request.</p>",
      "ID_der_akzeptierten_Antwort": null,
      "Antwortanzahl": null,
      "Kommentaranzahl": 6,
      "Gemeineigentumsdatum": null,
      "Erstellungsdatum": 1343243633750000,
      "Favoritenanzahl": null,
      "Letztes_Aktivitätsdatum": 1343243633750000,
      "Letztes_Bearbeitungsdatum": null,
      "Anzeigename_des_letzten_Bearbeiters": null,
      "Benutzer_ID_des_letzten_Bearbeiters": null,
      "Anzeigename_des_Besitzers": null,
      "Benutzer_ID_des_Besitzers": 400654,
      "Eltern_ID": 11656868,
      "Posttyp_ID": 2,
      "Punktzahl": 1,
      "Schlagwörter": "",
      "Aufrufanzahl": null
    },
    {
      "ID": 3112592,
      "Titel": null,
      "Text": "<p>Reference arguments were originally invented AFAIK for one thing: <strong>operator overloading semantics</strong>. For example operator[] just must return a reference.</p> <p>It was then a subject of great debate whether the 'concealed pointer' should be used for anything else ever. </p> <p>Many development convention documents of many firms said never use references. If you need a pointer say so .</p> <p>However it was then discovered that references have one major advantage (no not the syntax sugar). It is this: a reference is guaranteed to be valid unless you work really hard to break it.</p> <p>Personally I still don't understand why I cannot do this in C++:</p> <pre><code>int a1 a2; int &amp;b = a1; &amp;b = a2; // Error. address of referenced is not an lvalue. Why?! </code></pre>",
      "ID_der_akzeptierten_Antwort": null,
      "Antwortanzahl": null,
      "Kommentaranzahl": 6,
      "Gemeineigentumsdatum": null,
      "Erstellungsdatum": 1277402054163000,
      "Favoritenanzahl": null,
      "Letztes_Aktivitätsdatum": 1436303301943000,
      "Letztes_Bearbeitungsdatum": 1436303301943000.0,
      "Anzeigename_des_letzten_Bearbeiters": null,
      "Benutzer_ID_des_letzten_Bearbeiters": 63550.0,
      "Anzeigename_des_Besitzers": null,
      "Benutzer_ID_des_Besitzers": 73656,
      "Eltern_ID": 3112550,
      "Posttyp_ID": 2,
      "Punktzahl": 5,
      "Schlagwörter": "",
      "Aufrufanzahl": null
    },
    {
      "ID": 11273340,
      "Titel": null,
      "Text": "<p><code>Ishoppingcart::addToCart()</code> states that the method does not take any parameter while the implementation <code>Shoppingcart::addToCart(Product $product)</code> requires that a parameter of type <code>Product</code> must be passed into the method. This means that both declarations are incompatible and while the implemented interface must be satisfied PHP throws the shown error.</p> <p>Solution would be to either change <code>Ishoppingcart::addToCart()</code> to <code>Ishoppingcart::addToCart(Product $product)</code> so that it requires a parameter of type <code>Product</code> or to change <code>Shoppingcart::addToCart(Product $product)</code> to allow no parameter to passed into the method: <code>Shoppingcart::addToCart(Product $product = null)</code>;</p> <p>The correct way depends on your application requirements.</p>",
      "ID_der_akzeptierten_Antwort": null,
      "Antwortanzahl": null,
      "Kommentaranzahl": 6,
      "Gemeineigentumsdatum": null,
      "Erstellungsdatum": 1341051808937000,
      "Favoritenanzahl": null,
      "Letztes_Aktivitätsdatum": 1341051808937000,
      "Letztes_Bearbeitungsdatum": null,
      "Anzeigename_des_letzten_Bearbeiters": null,
      "Benutzer_ID_des_letzten_Bearbeiters": null,
      "Anzeigename_des_Besitzers": null,
      "Benutzer_ID_des_Besitzers": 11354,
      "Eltern_ID": 11273313,
      "Posttyp_ID": 2,
      "Punktzahl": 14,
      "Schlagwörter": "",
      "Aufrufanzahl": null
    }
  ]
}